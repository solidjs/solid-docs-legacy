# Начало работы

## Пробуем Solid

Безусловно, самый простой способ начать работу с Solid - это попробовать его онлайн. [Наш REPL](https://playground.solidjs.com) - идеальный способ опробовать ваши идеи. Также у нас есть [Sandbox](https://codesandbox.io/), где вы можете отредактировать любой из [наших примеров](https://github.com/solidjs/solid/blob/main/documentation/resources/examples.md).

Кроме того, вы можете использовать наши простые [Vite](https://vitejs.dev/) шаблоны, выполнив следующие команды в своем терминале:

```sh
> npm create vite@latest my-app -- --template solid
> cd my-app
> npm i #  yarn/pnpm
> npm run dev #  yarn/pnpm
```

Или с поддержкой TypeScript:

```sh
> npm create vite@latest my-app -- --template solid-ts
> cd my-app
> npm i # yarn/pnpm
> npm run dev # yarn/pnpm
```

## Изучаем Solid

Идея Solid состоит в том, что ваше приложение состоит из маленьких кусочков которые служат строительными блоками для приложений. Эти кусочки в основном представляют из себя функции, составляющие поверхностный API. К счастью, для начала вам не нужно знать о большинстве из них для работы с Solid.

В вашем распоряжении есть два основных типа строительных блоков: компоненты и реактивные примитивы.

Компоненты - это функции, которые принимают входные параметры (так называемые `пропсы`) и возвращают JSX элементы, включая DOM элементы и другие компоненты. Компоненты именуются в PascalCase и представляют из себя JSX элементы:

```jsx
// Компонент
function MyComponent(props) {
  return <div>Привет {props.name}</div>;
}

<MyComponent name="Solid" />;
```

Компоненты легковесны, поскольку сами не имеют состояния и не имеют экземпляров. Вместо этого они служат функциями для создания для элементов DOM и реактивных примитивов.

Детальная (`fine-grained`) реактивность  Solid основана на трех простых примитивах: `Сигнал`, `Мемо` и `Эффект`. Вместе они образуют механизм синхронизации с автоматическим отслеживанием, который обеспечивает обновленность вашего пользовательского интерфейса. Реактивные вычисления выполняются синхронно и принимают форму простых выражений обернутых в функции.

```js
// Реактивный примитив - `Сигнал`
const [a, setA] = createSignal(10);
const [b, setB] = createSignal(5);

// `Эффект`
createEffect(() => {
  const sum = a() + b();
  console.log(`${a()} + ${b()} = ${sum}`);
});
```

Вы можете узнать больше о [Реактивности Solid](/guides/reactivity) и [Solid Рендеринг](/guides/rendering).

## Философия Solid

Solid легче изучить и использовать, если вы знаете его философию.

В дизайне Solid заложены несколько основополагающих принципов и ценностей, которые помогут нам лучше всего создавать веб-сайты и приложения.

### 1. Декларативные данные

Декларативные данные - это практика привязки описания поведения данных к их объявлениям.
Это позволяет нам легко связывать данные с их поведением и хранить это всё в одном месте.

### 2. Исчезающие компоненты

Достаточно сложно структурировать компоненты без учета обновлений. Обновления в Solid полностью независимы от компонентов. Компонентные функции вызываются один раз, а затем просто исчезают. Компоненты существуют для организации вашего кода и ничего больше.

### 3. Разделение чтения/записи

Точный контроль и предсказуемость делают системы лучше. Нам не нужна настоящая неизменяемость (`immutability`), чтобы обеспечить однонаправленный поток, нам просто нужна способность принимать осознанное решение.

### 4. Простое лучше легкого

В процессе создания идеального библиотеки неспроста была выбрана детальная реактивность. Наша цель состоит в том, чтобы предоставить разработчику минимальные инструменты, которые могли бы служить хорошим фундаментом для построения UI.


## Веб-компоненты

По изначальной задумке Solid был библиотекой для работы с веб-компонентами. Со временем дизайн и цели Solid изменились. Впрочем, Solid по-прежнему остается отличным способом создания веб-компонентов. [Solid-элемент](https://github.com/solidjs/solid/tree/main/packages/solid-element) позволяет писать и оборачивать функциональные компоненты Solid для создания небольших и производительных веб-компонентов. Solid-элемент может использовать Solid Context API, а порталы Solid поддерживают Shadow DOM для добавления изолированных стилей.

## Рендеринг на стороне сервера

Solid предлагает решение для динамического рендеринга на стороне сервера, которое обеспечивает поистине изоморфный опыт разработки. Использование `Ресурсов`, встроенных в библиотеку Solid, для асинхронных запросов не просто облегчает работу со внешними API, но и автоматически сериализует и синхронизирует полученные данные между клиентом и браузером.

Поскольку Solid поддерживает асинхронный и рендеринг с помощью [стримов](https://developer.mozilla.org/ru/docs/Web/API/Streams_API) на сервере, вам не нужно думать об особенностях работы вашего кода на сервере - он будет отлично работать из коробки. Современная архитектура Solid и поддержка стримов означает, что такие фичи, как [render-as-you-fetch](https://ru.reactjs.org/docs/concurrent-mode-suspense.html#approach-3-render-as-you-fetch-using-suspense) и [разделение кода](https://ru.reactjs.org/docs/code-splitting.html) будут работать без проблем.

Для получения дополнительной информации прочтите [Рендеринг на стороне сервера](/guides/server#server-side-rendering).

## Нет компиляции?

Не любите JSX? Не возражаете вручную оборачивать ваши выражения, падения производительности и больших размеров файлов? В качестве альтернативы вы можете использовать [теговые шаблоны](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Template_literals#%D1%82%D0%B5%D0%B3%D0%BE%D0%B2%D1%8B%D0%B5_%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B_%D0%B8_%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2) или HyperScript в средах в которых у вас нет возможности использовать компилятор.

Запускать их можно прямо из браузера, используя [Skypack](https://www.skypack.dev/):

```html
<html>
  <body>
    <script type="module">
      import {
        createSignal,
        onCleanup,
      } from "https://cdn.skypack.dev/solid-js";
      import { render } from "https://cdn.skypack.dev/solid-js/web";
      import html from "https://cdn.skypack.dev/solid-js/html";

      function App() {
        const [count, setCount] = createSignal(0);
        const timer = setInterval(() => setCount(count() + 1), 1000);

        onCleanup(() => clearInterval(timer));
        return html`<div>${count}</div>`;
      }

      render(App, document.body);
    </script>
  </body>
</html>
```

Помните, что вам все еще нужна соответствующая библиотека выражений DOM для их работы с TypeScript. Вы можете использовать теговые шаблонные литералы с [Lit DOM Выражениями](https://github.com/ryansolid/dom-expressions/tree/main/packages/lit-dom-expressions) или HyperScript с [Hyper DOM Выражениями](https://github.com/ryansolid/dom-expressions/tree/main/packages/hyper-dom-expressions).