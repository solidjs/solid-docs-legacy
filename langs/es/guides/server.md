# Server Side Rendering

Solid maneja el renderizado en servidor compilando los templates JSX a un c칩digo ultra eficiente de adici칩n de cadenas de texto. Esto puede ser logrado mediante el _plugin_ de Babel o un _preset_ a침adiendo `generate: "ssr"`. Para ambos, cliente y servidor es necesario a침adirle `hydratable: true` para generar el c칩digo compatible con la hidrataci칩n.

Los entornos de ejecuci칩n `solid-js` y `solid-js/web` se intercambian por contrapartes no-reactivas cuando se ejecutan en un entorno de node. Para otros ambientes necesitas empaquetar el c칩digo de servidor con exportaciones condicionales establecidos a `node`. La mayor칤a empaquetadores tienen una manera de hacer esto. En general tambi칠n recomendamos usar las condiciones de exportaci칩n `solid`, as칤 como tambi칠n se recomienda que las librer칤as env칤en su fuente bajo la exportaci칩n `solid`.

Construir para SSR definitivamente toma un poco mas de configuraci칩n pues estaremos generando 2 _bundles_ separados. La entrada del cliente deber칤a usar `hydrate`:

```jsx
import { hydrate } from "solid-js/web";

hydrate(() => <App />, document);
```

_Nota: Es posible renderizar e hidratar desde la ra칤z del documeno. Esto permite que describamos nuestra vista completa en JSX._

La entrada del servidor puede usar una de cuatro opciones de renderizado ofrecidas por Solid. Cada una produce el _output_ y una etiqueta de script para ser insertado en el `head` del documento.

```jsx
import { renderToString, renderToStringAsync, renderToStream } from "solid-js/web";

//Renderizado s칤ncrono de strings
const html = renderToString(() => <App />);

//Renderizado as칤ncrono de strings
const html = await renderToStringAsync(() => <App />);

// Renderizado en Stream
const stream = renderToStream(() => <App />);

// Node
stream.pipe(res);

// Streams web (para servicios como Cloudflare Workers)
const { readable, writable } = new TransformStream();
stream.pipeTo(writable);
```

Para su comodidad `solid-js/web` exporta un indicador `isServer`. Esto es 칰til ya que la mayor칤a de los _bundlers_ podr치n realizar _treeshaking_ en cualquier recurso que este bajo esta indicador o importar solo el c칩digo utilizado bajo este indicador fuera de su _bundle_ de cliente.

```jsx
import { isServer } from "solid-js/web";

if (isServer) {
	// solo ejecuta esto en el servidor
} else {
	// solo ejecuta esto en el navegador
}
```

## Hydration Script

Para hidratar progresivamente incluso antes de que se cargue el entorno de ejecuci칩n de Solid, se debe insertar un script especial en la p치gina. Puede generarse e insertarse a trav칠s de `generateHydrationScript` o incluirse como parte del JSX usando la etiqueta `<HydrationScript />`.

```js
import { generateHydrationScript } from "solid-js/web";

const app = renderToString(() => <App />);

const html = `
  <html lang="en">
    <head>
      <title>游댠 Solid SSR 游댠</title>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="stylesheet" href="/styles.css" />
      ${generateHydrationScript()}
    </head>
    <body>${app}</body>
  </html>
`;
```

```jsx
import { HydrationScript } from 'solid-js/web';

const App = () => {
  return (
    <html lang="en">
      <head>
        <title>游댠 Solid SSR 游댠</title>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="stylesheet" href="/styles.css" />
        <HydrationScript />
      </head>
      <body>{/*... el resto de la App*/}</body>
    </html>
  );
};
```

Cuando se hidrata desde el documento, la inserci칩n de recursos que no est치n disponibles en la ejecuci칩n del cliente tambi칠n puede arruinar el proceso cuando no est치n bajo la etiqueta `<head>`. Solid proporciona un componente `<NoHydration>` cuyos hijos funcionar치n normalmente en el servidor pero no se hidratar치n en el navegador.

```jsx
<NoHydration>
  <ImNotHydrated />
</NoHydration>
```

## Async y Streaming SSR

Estos mecanismos se basan en el conocimiento de Solid sobre c칩mo funciona tu aplicaci칩n. Utiliza Suspense y Resource API en el servidor, en lugar de obtener datos y luego renderizar. Solid obtiene los recursos al mismo tiempo que renderiza en el servidor, de la misma forma que lo hace en el cliente. Tu c칩digo est치 escrito exactamente de la misma manera.

El renderizado as칤ncrono espera hasta que todos los l칤mites del Suspense sean resueltos y entonces env칤a los resultados (o los escribe en un archivo en caso de ser Generaci칩n de Sitios Est치ticos).

El streaming env칤a contenido s칤ncrono al navegador inmediatamente. Inicialmente, renderiza en el servidor tus respaldos del Suspense y los env칤a al cliente. Despu칠s, en el momento en que los datos as칤ncronos terminan de cargar en el servidor, enviamos al cliente los datos y el HTML usando el mismo stream. El navegador finaliza el trabajo, resuelve el componente Suspense, y reemplaza el respaldo con contenido real. 

La ventaja de este enfoque:

- El servidor no tiene que esperar la respuesta de los datos as칤ncronos. Los recursos pueden empezar a cargar antes en el navegador, as칤 el usuario puede empezar a ver contenido antes.
- Comparado con la obtenci칩n de datos del lado del cliente como en JAMStack, la carga de datos en el servidor comienza inmediatamente y no necesita esperar a que el cliente JavaScript cargue.
- Todos los datos son serializados y transportados desde el servidor al cliente de forma autom치tica.

## Advertencias sobre el SSR

La soluci칩n SSR isomorfa de Solid es muy poderosa porque puede escribir su c칩digo principalmente como una base de c칩digo 칰nico que se ejecuta de manera similar en ambos entornos. Sin embargo esto genera expectativas en la hidrataci칩n. Principalmente, la vista renderizada en el cliente es la misma que se renderizar칤a en el servidor. No es necesario que sea exacto en t칠rminos de texto, pero estructuralmente el etiquetado debe ser el mismo.

En el servidor usamos indicadores renderizados para igualar los elementos y las ubicaciones de los recursos en el servidor. Por este motivo el cliente y el servidor deber치n tener los mismos componentes. Esto no es usualmente un problema dado que Solid renderiza de la misma forma en el cliente y en el servidor. Pero actualmente no existe una forma de renderizar algo en el servidor que no sea hidratado en el cliente. En este momento no hay forma de hidratar parcialmente una p치gina completa, y no generar indicadores para ello. Es todo o nada. La hidrataci칩n parcial es algo que queremos explorar en el futuro.

Finalmente, todos los recursos deben definirse bajo el 치rbol `render`. Estos se serializan autom치ticamente y son captados en el navegador, pero eso funciona porque los m칠todos de `render` realizan un seguimiento del progreso de la renderizaci칩n. Algo que no podemos hacer si se crean en un contexto aislado. Del mismo modo, no hay reactividad en el servidor, por lo que no debe actualizar las se침ales en el renderizado inicial y esperar que se reflejen m치s arriba en el 치rbol. Si bien tenemos l칤mites de Suspense, el SSR de Solid es b치sicamente de arriba hacia abajo.

## Iniciando con SSR

Las configuraciones de SSR son complicadas. Tenemos algunos ejemplos en el paquete [solid-ssr](https://github.com/solidjs/solid/blob/main/packages/solid-ssr).

Sin embargo, se est치 trabajando en un nuevo _starter_ [SolidStart](https://github.com/solidjs/solid-start) que tiene como objetivo hacer que esta experiencia sea mucho m치s amigable.

## Iniciando con la Generaci칩n de Sitios Est치ticos SSG

[solid-ssr](https://github.com/solidjs/solid/blob/main/packages/solid-ssr) tambi칠n viene con una sencilla utilidad para generar sitios est치ticos o renderizados previamente. Lea el README para obtener m치s informaci칩n.
