# FAQ

### 仮想 DOM なしの JSX？　ベーパーウェア（概念だけで実態のないソフト）ですか？　これは不可能だという有名な意見を聞いたことがあります

React の更新モデルを持っていなければ可能です。JSX は Svelte や Vue のようなテンプレート言語と同じで、特定の点ではより柔軟性があります。任意の JavaScript を挿入するのは難しい場合もありますが、スプレッド演算子をサポートするのと変わりません。つまり、これはベーパーウェアではなく、最もパフォーマンスが高いことが証明されているアプローチなのです。

本当のメリットは、拡張性の高さにあります。私たちは、最適なネイティブ DOM 更新を行うためにコンパイラを用意していますが、React のようなライブラリの自由度はすべて持っています。レンダープロップや高階コンポーネントなど、標準的な技術を使ったコンポーネントを、リアクティブな「フック」とともに記述できるのです。Solid の制御フローの仕組みが気に入らない？　自分で書きましょう。

### Solid どれほどパフォーマンスが優れていますか？

何か 1 つを挙げることができればいいのですが、実際にはいくつかの重要な設計上の決定が組み合わされています。

1. 明示的なリアクティビティ、つまりリアクティブであるべきものだけを追跡します。
2. 初期生成を考慮したコンパイル。Solid はヒューリスティックを使い、適切な表現を組み合わせることで計算回数を減らし、重要な更新の粒度とパフォーマンスを維持しています。
3. リアクティブな式は単なる関数です。これにより、不要なラッパーや同期のオーバーヘッドを取り除いた遅延 props 評価による「消えるコンポーネント」が可能になります。

これらは現在のところ、Solid が競合に対して優位に立つための組み合わせであり、独特な技術です。

### React との互換性、つまり Solid で私の React ライブラリを使う方法はありますか？

いいえ、これからもならないでしょう。API は似ていて、コンポーネントは小さな編集で移動できることが多いのですが、更新モデルは根本的に異なります。React コンポーネントは何度もレンダリングされるため、Hooks 以外のコードは非常に異なって動作します。Solid ではクロージャやフックのルールは不要なだけでなく、ここでは動作しないコードを規定することがあります。

一方で、Vue 互換は現在のところ実装の予定はありませんが可能でしょう。

一方、Solid を React で動作させることも可能です。[React Solid State](https://github.com/solidjs/react-solid-state)では、React の関数コンポーネント内で Solid の API にアクセスできるようになります。[reactjs-solidjs-bridge](https://github.com/Sawtaytoes/reactjs-solidjs-bridge) は Solid コンポーネント内で React コンポーネントをレンダリングしたり、その逆を行うことができ、アプリを徐々に移植する際に便利です。

### なぜテンプレートで `map` を使ってはいけないのですか？　また、`<For>` と `<Index>` の違いは何ですか？

配列が静的なものであれば、map を使っても問題はないでしょう。しかし、Signal やリアクティブなプロパティをループする場合、`map` は非効率です。何らかの理由で配列が変更されると、map 全体が再実行され、すべてのノードが再作成されることになるからです。

`<For>` と `<Index>` はどちらも、これよりも賢いループソリューションを提供します。これらはレンダリングされた各ノードと配列の要素を結びつけており、配列の要素が変更されると、対応するノードだけが再レンダリングされます。

`<Index>` はインデックスによってこれを行います。つまり各ノードが配列のインデックスに対応します。`<For>` は値によってこれを行います。つまり各ノードが配列内のデータの一部に対応します。このため、コールバックでは `<Index>` がアイテムの Signal を出力します。各アイテムのインデックスは固定とみなされますが、そのインデックスのデータは変更可能です。一方、`<For>` は、インデックスに対する Signal を与えます。各アイテムの内容は固定とみなされますが、要素は配列内で移動可能です。

例えば配列の 2 つの要素が入れ替わった場合、 `<For>` は対応する 2 つの DOM ノードを再配置し、その過程で `index()` Signal を更新します。`<Index>` は DOM ノードを再配置しませんが、2 つの DOM ノードの `item()` Signal を更新し、再レンダリングを行います。

この違いについての詳細なデモは、Ryan のストリームの[この部分](https://www.youtube.com/watch?v=YxroH_MXuhw&t=2164s)を参照してください。
### なぜ props やストアで分割代入が動作しないのですか？

props と Store オブジェクトでは、リアクティビティはプロパティアクセスで追跡されます。リアクティブなコンテキストで `props.whatever` を呼び出すと、そのコンテキストを追跡してプロパティが変更されたときにそれを更新するように Solid に指示されます。分割代入をするとオブジェクトから値を分離してその時点の値を取得するので、リアクティビティは失われます。

### `onChange` イベントハンドラーが時間通りに起動しないのはなぜですか？

一部のフレームワークでは、入力の `onChange` イベントが、キーを押すたびに発生するように変更されています。しかし、これは `onChange` イベントの[ネイティブな動作方法](https://developer.mozilla.org/ja/docs/Web/API/GlobalEventHandlers/onchange)ではありません。これは、input への「コミットされた」変更を反映することを意図しており、通常は input がフォーカスを失ったときに発生します。入力の値に対するすべての変更を処理するには、`onInput` を使用します。

### クラスコンポーネントのサポートを追加してくれますか？　ライフサイクルの方が推論しやすいと思います。

クラスコンポーネントをサポートするつもりはありません。Solid におけるコンポーネントのライフサイクルは、リアクティブシステムのスケジューリングに結びついており、人為的なものです。クラスを作ることはできますが、事実上、render 関数を含むイベントハンドラー以外のコードはすべてコンストラクタで実行されます。これは、データの粒度を小さくするための言い訳のための構文に過ぎません。

ライフサイクルではなく、データとその振る舞いをまとめてください。これは何十年にもわたって機能してきたリアクティブなベストプラクティスです。

### 7. 私は JSX がとても嫌いなのですが、何か別のテンプレート言語の可能性はありますか？　あ、タグ付きテンプレートリテラル/HyperScript があるんですね。使ってみようかな……。

やめてください。ここでやめておきましょう。Svelte がテンプレートを使って最適化された DOM 命令を作成するのと同じように、私たちは JSX を使っています。タグ付きテンプレートリテラルや HyperScript のソリューションは、それ自体はとても素晴らしいものかもしれませんが、ビルド不可の要件のような現実的な理由がない限りあらゆる面で劣っています。バンドルが大きくなり、パフォーマンスが低下し、値のラップを手動で行う必要があります。

選択肢があるのは良いことですが、Solid の JSX はここでは本当に最適なソリューションです。テンプレート DSL も制限が多いとはいえ素晴らしいですが、JSX は無料で多くのことを提供してくれます。既存のパーサー、シンタックスハイライト、Prettier、コード補完、そして最後に TypeScript です。

他のライブラリもこれらの機能のサポートを追加してきましたが、それは膨大な努力を必要とし、まだ不完全で、常にメンテナンスに頭を悩ませています。これは本当に現実的なスタンスを取っています。

### Signal とストアはどのような場合に使用するのですか？　なぜこれらは違うのですか？

ストアはネストした値を自動的にラップするので、深いデータ構造やモデルのようなものに最適です。それ以外のほとんどの用途では、Signal は軽量で、素晴らしい働きをします。

これらを 1 つのものとしてまとめたいところですが、プリミティブをプロキシすることはできません。関数は最もシンプルなインターフェイスで、あらゆるリアクティブな式（状態のアクセスを含む）をトランスポート上で 1 つにまとめることができるため、ユニバーサルな API を提供します。Signal や状態に好きな名前をつけることができ、最小限の機能にとどめることができます。エンドユーザーに `.get()` `.set()` の入力を強要したり、さらに悪いことに `.value` の入力を強要したりすることは絶対に避けたいことです。少なくとも、前者は簡潔にするためにエイリアスを付けることができますが、後者は関数を呼び出すための最も簡潔な方法に過ぎません。

### Vue のように Solid のストアに値を代入できないのはなぜですか。 Svelte、または MobX？　双方向バインディングはどこにありますか？

リアクティビティは強力なツールですが、同時に危険なツールでもあります。MobX はこのことを理解していて、Strict モードと Actions を導入して、更新が発生する場所や時間を制限しています。データのコンポーネントツリー全体を扱う Solid では、React から何かを学べることが明らかになりました。同じ契約を持つための手段を提供する限り、実際にイミュータブルである必要はありません。

状態を更新する能力を渡せるかどうかは、状態を渡すかどうかを決めるよりも間違いなく重要です。だから、それを分離できることは重要であり、読み取りがイミュータブルである場合にのみ可能です。また、細かく更新できるのであれば、不変性のコストを払う必要はありません。幸いなことに、ImmutableJS と Immer の間には大量の先行技術があります。皮肉なことに、Solid はミュータブルな内部とイミュータブルなインターフェイスを持つ逆 Immer のように振る舞います。

### Solid のリアクティビティを単体で使うことはできますか？

もちろんです。単体のパッケージは提供していませんが、コンパイラなしの Solid をインストールし、リアクティブプリミティブを使用することは簡単です。きめ細かいリアクティビティの利点の 1 つは、ライブラリに依存しないことです。それどころか、ほとんどすべてのリアクティブライブラリがこの方法で動作します。それが [Solid](https://github.com/solidjs/solid) に影響を与えたものであり、その基礎となる [DOM Expressions library](https://github.com/ryansolid/dom-expressions) が純粋にリアクティブシステムからレンダラーを作るきっかけとなりました。

試しにいくつか挙げてみましょう: [Solid](https://github.com/solidjs/solid)、[MobX](https://github.com/mobxjs/mobx)、[Knockout](https://github.com/knockout/knockout)、[Svelte](https://github.com/sveltejs/svelte)、[S.js](https://github.com/adamhaile/S)、[CellX](https://github.com/Riim/cellx)、[Derivable](https://github.com/ds300/derivablejs)、[Sinuous](https://github.com/luwes/sinuous)、そして最近では [Vue](https://github.com/vuejs/vue) などです。リアクティブなライブラリを作るには、例えば [lit-html](https://github.com/Polymer/lit-html) のようにレンダラーにタグ付けするよりもはるかに多くのことが必要ですが、感触をつかむには良い方法です。

### Solid には、Next.js や Material Components のようなライブラリはありますか？

制作中です！　もしエコシステム構築に興味があれば、私たちの [Discord](https://discord.com/invite/solidjs) で既存のエコシステムの取り組みに参加したり、独自のエコシステムを立ち上げたりできます。
