{"id":"styledjsx","files":[{"name":"main","type":"jsx","content":"import { createSignal } from \"solid-js\";\nimport { render } from \"solid-js/web\";\n\nfunction Button() {\n  const [isLoggedIn, login] = createSignal(false);\n  return (\n    <>\n      <button className=\"button\" onClick={() => login(!isLoggedIn())}>\n        {isLoggedIn() ? \"Log Out\" : \"Log In\"}\n      </button>\n      <style jsx dynamic>\n        {`\n          .button {\n            background-color: ${isLoggedIn() ? \"blue\" : \"green\"};\n            color: white;\n            padding: 20px;\n            margin: 10px;\n          }\n        `}\n      </style>\n    </>\n  );\n}\n\nrender(\n  () => (\n    <>\n      <Button />\n      <Button />\n    </>\n  ),\n  document.getElementById(\"app\")\n);"},{"name":"tab1","type":"jsx","content":"import { createState } from \"solid-js\";\n\nfunction checkValid({ element, validators = [] }, setErrors, errorClass) {\n  return async () => {\n    element.setCustomValidity(\"\");\n    element.checkValidity();\n    let message = element.validationMessage;\n    if (!message) {\n      for (const validator of validators) {\n        const text = await validator(element);\n        if (text) {\n          element.setCustomValidity(text);\n          break;\n        }\n      }\n      message = element.validationMessage;\n    }\n    if (message) {\n      errorClass && element.classList.toggle(errorClass, true);\n      setErrors({ [element.name]: message });\n    }\n  };\n}\n\nexport function useForm({ errorClass }) {\n  const [errors, setErrors] = createState({}),\n    fields = {};\n\n  const validate = (validators = []) => {\n    return ref => {\n      let config;\n      fields[ref.name] = config = { element: ref, validators };\n      ref.onblur = checkValid(config, setErrors, errorClass);\n      ref.oninput = () => {\n        if (!errors[ref.name]) return;\n        setErrors({ [ref.name]: undefined });\n        errorClass && ref.classList.toggle(errorClass, false);\n      };\n    };\n  };\n\n  const handleSubmit = (callback = () => {}) => {\n    return ref => {\n      ref.setAttribute(\"novalidate\", \"\");\n      ref.onsubmit = async e => {\n        e.preventDefault();\n        let errored = false;\n\n        for (const k in fields) {\n          const field = fields[k];\n          await checkValid(field, setErrors, errorClass)();\n          if (!errored && field.element.validationMessage) {\n            field.element.focus();\n            errored = true;\n          }\n        }\n        !errored && callback(ref);\n      };\n    };\n  };\n\n  return { validate, handleSubmit, errors };\n}\n"}]}