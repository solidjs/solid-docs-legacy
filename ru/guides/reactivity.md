---
title: Реактивность
description: Обзор реактивности Solid.
sort: 1
---

# Реактивность

Управление данными в Solid построено на гибких реактивных примитивах, которые отвечают за все обновления. Solid использует подход, очень похожий на MobX или Vue, за тем исключением, что он не жертвует своей точностью в пользу Virtual DOM. Зависимости автоматически отслеживаются, когда вы обращаетесь к реактивным значениям в `Эффектах` и JSX.

Примитивы Solid представлены в виде `create` функций, в основном возвращающих кортежи (`tuples`), в которых первый элемент обычно является считываемым примитивом - [геттером](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/get), а второй - обновляющим [сеттером](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/set). Обычно, когда мы говорим о названии примитива (например `Сигнале`), мы имеем в виду считываемую часть.

Вот, к примеру, базовый счетчик, который увеличивается раз в секунду, и обновляет наш UI в зависимости от значения `Сигнала` `count`:

```jsx
import { createSignal, onCleanup } from "solid-js";
import { render } from "solid-js/web";

const App = () => {
  const [count, setCount] = createSignal(0),
    timer = setInterval(() => setCount(count() + 1), 1000);
  onCleanup(() => clearInterval(timer));

  return <div>{count()}</div>;
};

render(() => <App />, document.getElementById("app"));
```

## Введение в примитивы

Solid состоит из 3 основных примитивов: `Сигнал`, `Мемо` и `Эффект`. В их основе лежит паттерн наблюдатель (`observer`), в котором `Сигналы` (и `Мемо`) отслеживаются путем использования в `Мемо` и `Эффекты`.

`Сигналы` — простейшие примитивы. Они содержат значение, а также геттеры и сеттеры, чтобы мы знали, когда они считываются и обновляются.

```js
const [count, setCount] = createSignal(0);
```

`Эффекты` — это функции, которые оборачивают считывание нашего `Сигнала` и повторно вызываются при изменении значения зависимого `Сигнала`. Это полезно для создания сайд эффектов, таких как, например, рендеринг.

```js
createEffect(() => console.log("Последнее значение счетчика", count()));
```

`Мемо` — это кэшированные производные значения. Они обладают свойствами как `Сигналов`, так и Эффектов. Они отслеживают свои собственные зависимые `Сигналы`, повторно выполняясь только при их изменении, а также сами являются отслеживаемыми `Сигналами`.

```js
const fullName = createMemo(() => `${firstName()} ${lastName()}`);
```

## Прицип работы

`Сигналы` — это эмиттеры событий, которые содержат список подписок. Они уведомляют своих подписчиков всякий раз, когда их значение меняется.

Еще более интересно то, как происходит подписка на события. Solid использует автоматическое отслеживание зависимостей. Обновления происходят автоматически, как только данные изменяются.

Вся суть заключается в глобальном стеке во время выполнения. Прежде, чем `Эффект` или `Мемо` выполнят (или выполнят повторно) функцию, переданную разработчиком, они помещают себя в этот самый стек. Затем любой `Сигнал` при считывании значения проверяет, есть ли подписчик в стеке, и если есть, то добавляет его в список подписок.

Вы можете представить себе это следующим образом:

```js
function createSignal(value) {
  const subscribers = new Set();

  const read = () => {
    const listener = getCurrentListener();
    if (listener) subscribers.add(listener);
    return value;
  };

  const write = (nextValue) => {
    value = nextValue;
    for (const sub of subscribers) sub.run();
  };

  return [read, write];
}
```

Теперь всякий раз, когда мы обновляем `Сигнал`, мы знаем, какие `Эффекты` нужно запустить повторно. Просто, но эффективно. Фактическая реализация, конечно, намного сложнее, но суть происходящего именно такова.

Для более подробного понимания того, как работает реактивность, будет полезно прочитать следующие статьи:

[Практическое введение в реактивность](https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf)

[Создание реактивной библиотеки с нуля](https://dev.to/ryansolid/building-a-reactive-library-from-scratch-1i0p)

[SolidJS: От реактивности до рендеринга](https://indepth.dev/posts/1289/solidjs-reactivity-to-rendering)

## Особенности реактивности Solid

Такой подход к реактивности очень мощный и динамичный. Он может обрабатывать зависимости на лету, посредством выполнения различных ветвей условного кода. Данный подход также работает на многих уровнях косвенного обращения. Также отслеживается любая функция, выполняемая внутри области отслеживания.

Однако есть некоторые ключевые особенности поведения и компромиссы, о которых мы должны знать.

1. Вся реактивность отслеживается из вызовов функций, впрямую или из функций скрытых под каким-либо геттером/прокси и запускается реактивность при доступе к свойству. Это означает, важно понимать откуда вы получаете доступ к свойствам реактивных объектов.

2. Компоненты и обратные вызовы из потоков управления не отслеживают области видимости и выполняются только один раз. Это означает, что деструктуризация или выполнение логики верхнего уровня в ваших компонентах не будет выполняться повторно. Доступ к этим `Сигналам`, `Сторам` и `Пропсам` должен быть осуществлен внутри других реактивных примитивов или JSX, чтобы эта часть кода могла быть повторно оценена.

3. В данном подходе отслеживание идет только синхронно. Если у вас есть setTimeout или же вы используете асинхронную функцию в своем `createEffect`, код, который будет выполняться асинхронно, не будет отслеживаться.
